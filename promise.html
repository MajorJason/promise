<!DOCTYPE html>
<html>
<head>
<title>promise</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>ES6 中的Promise对象</h1>
<h2>写在前面</h2>
<p>首先看一个demo</p>
<pre><code>$.ajax({
    url: 'XXX',
    success: function (data) {
        //第二个请求依赖第一个请求
        $.ajax({
            // 要在第一个请求成功后才可以执行下一步
            url: 'xxx',
            success: function (data) {
                 // ......
            }
        });
    }
});
</code></pre>

<p>这种写法的函数回调，理解起来不难，但在实际开发中有一些缺点</p>
<ul>
<li>在多个回调的时候，会导致回调函数的嵌套，这就是常说的回调深渊。</li>
<li>如果几个异步操作之间不分先后顺序时，同样需要等待上一个完成后在执行下一个。</li>
</ul>
<p>为了解决这个问题，在ES6中<code>Promise</code>对象应运而生。</p>
<h2>1.什么是Promise</h2>
<p><code>promise</code>是异步编程的一种解决方案，比传统的解决方法更合理和更强大。简单来说他就是一个容器，保存着未来才会结束的事件（通常是异步操作）的结果。有了<code>promise</code>对象，可以将异步操作以同步操作的流程表达出来，避免层层嵌套的回调。</p>
<p>当然<code>promise</code>也有一些缺点，首先他无法取消，一单新建就会立即执行，无法取消。其次，如果不设置回调函数，promise内部会抛出错误，不会反映到外部。最后，处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段。</p>
<h2>2.Promise的基本用法</h2>
<p><code>Promise</code>对象代表一个未完成，但预计将来会完成的操作。它有三种状态：</p>
<ul>
<li><code>pending</code> ：初始值，不是<code>fulfilled</code>，也不是<code>regected</code>；</li>
<li><code>fulfilled</code> ：代表操作成功</li>
<li><code>regected</code> ：代表操作失败</li>
</ul>
<p><code>Promise</code>有两种状态的改变，可从<code>pending</code>转变成另外两种状态。一旦状态改变，就不会发生变化。状态变化后<code>promise.then</code>绑定的函数就会被调用。 </p>
<pre><code>//构建Promise
var promise = new Promise(function (resolve, reject) {
    if (/* 异步操作成功 */) {
        resolve(data);
    } else {
        /* 异步操作失败 */
        reject(error);
    }
});
</code></pre>

<p>我们使用new来构建一个Promise。Promise接受一个函数作为参数，该函数有两个参数分别为resolve和reject。这两个函数就是回调函数。</p>
<ul>
<li>resolve函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>
<li>reject 函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去；</li>
</ul>
<p>Promise实例生成以后，可以用then方法指定resolved和reject状态的回调函数。</p>
<pre><code>promise.then(onFulfilled, onRejected);

promise.then(function(data) {
    // do something when success
}, function(error) {
     // do something when failure
});
</code></pre>

<p>then方法会返回一个Promise。他有两个参数，分别为Promise从pending变为fulfilled和reject时的回调函数。这两个函数都接受Promise对象传出的值作为参数。简单来说，then就是定义resolve和reject函数的。</p>
<p>Promise新建后悔立即执行。而then方法中指定的回调函数，将在当前脚本所有同步任务执行完才会执行。</p>
<pre><code>var promise = new Promise(function(resolve, reject) {
    console.log('before resolved');
    resolve();
    console.log('after resolved');
});

promise.then(function() {
    console.log('resolved');
});

console.log('outer');

-------output-------
before resolved
after resolved
outer
resolved
</code></pre>

<p>由于resolve指定的是异步操作成功后的回调函数，它需要等所有同步代码执行后才会执行。</p>
<h2>3.Promise的API</h2>
<h3>.then()</h3>
<pre><code>语法：Promise.prototype.then(onFulfilled, onRejected)
</code></pre>

<p>对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个心Promise的resolve函数。</p>
<h3>.catch()</h3>
<pre><code>语法：Promise.prototype.catch(onRejected)
</code></pre>

<p>该方法是.then（undefined, onRejected)的别名，用于指定发生错误时的回调函数。</p>
<pre><code>promise.then(function(data) {
    console.log('success');
}).catch(function(error) {
    console.log('error', error);
});

/*******等同于*******/
promise.then(function(data) {
    console.log('success');
}).then(undefined, function(error) {
    console.log('error', error);
});

//demo

var promise = new Promise(function (resolve, reject) {
    throw new Error('test');
});
/*******等同于*******/
var promise = new Promise(function (resolve, reject) {
    reject(new Error('test'));
});

//用catch捕获
promise.catch(function (error) {
    console.log(error);
});
-------output-------
Error: test
</code></pre>

<p>regect方法的作用，等同于抛错。</p>
<p>promise对象的错误，会一直向后传递，直到被捕获。即错误总会被下一个catch所捕获。then方法指定的回调函数，若抛出错误，也会被下一个catch捕获。catch中也能抛错，则需要后面的catch来捕获。</p>
<p>如果promise一旦fulfilled了，再抛错，也不会变为rejected,就不会被catch了。</p>
<h3>.all()</h3>
<pre><code>语法：Promise.all(iterable)
</code></pre>

<p>该方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<pre><code>var p = Promise.all([p1,p2,p3]);
</code></pre>

<p>Promise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定</p>
<ul>
<li>当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数.demo1</li>
<li>
<p>当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数. demo2</p>
<pre><code>/* demo1 */
var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 3000, &quot;first&quot;);
});
var p2 = new Promise(function (resolve, reject) {
    resolve('second');
});
var p3 = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 1000, &quot;third&quot;);
}); 

Promise.all([p1, p2, p3]).then(function(values) { 
  console.log(values); 
});

-------output-------
//约 3s 后
[&quot;first&quot;, &quot;second&quot;, &quot;third&quot;]


/* demo2 */
var p1 = new Promise((resolve, reject) =&gt; { 
  setTimeout(resolve, 1000, &quot;one&quot;); 
}); 
var p2 = new Promise((resolve, reject) =&gt; { 
  setTimeout(reject, 2000, &quot;two&quot;); 
});
var p3 = new Promise((resolve, reject) =&gt; {
  reject(&quot;three&quot;);
});

Promise.all([p1, p2, p3]).then(function (value) {
    console.log('resolve', value);
}, function (error) {
    console.log('reject', error);    // =&gt; reject three
});

-------output-------
reject three
</code></pre>

</li>
</ul>
<h3>.race()</h3>
<pre><code>语法： Promise.race(iterable)
</code></pre>

<p>该方法同样是将多个Prmise实例，包装成一个新的Promise实例。</p>
<pre><code>var p = Promise.race([p1, p2, p3]);
</code></pre>

<h3>.resolve()</h3>
<p>语法：</p>
<pre><code>Promise.resolve(value);
Promise.resolve(promise);   
Promise.resolve(thenable);
</code></pre>

<p>它可以看做new Promise()的快捷方式；</p>
<pre><code>Promise.resolve('Success');

/*******等同于*******/
new Promise(function (resolve) {
    resolve('Success');
});
</code></pre>

<p>这段代码会让这个Promise对象立即进入<code>resolved</code>状态，并将结果<code>success</code>传递给<code>then</code>指定的<code>onFulfilled</code>回调函数。用于<code>Promise.resolve()</code>也是返回Promise对象，因此可以用<code>.then()</code>处理其返回值。</p>
<pre><code>Promise.resolve('success').then(function (value) {
    console.log(value);
});
-------output-------
Success
</code></pre>

<p><code>Promise.resolve()</code>的另一个作用就是将<code>thenable</code>对象（即带有<code>then</code>方法的对象）转换为promise对象。</p>
<pre><code>var p1 = Promise.resolve({ 
    then: function (resolve, reject) { 
        resolve(&quot;this is an thenable object!&quot;);
    }
});
console.log(p1 instanceof Promise);     // =&gt; true

p1.then(function(value) {
    console.log(value);     // =&gt; this is an thenable object!
  }, function(e) {
    //not called
});
</code></pre>

<h3>.reject()</h3>
<pre><code>语法：Promise.reject(reason)
</code></pre>

<p>这个方法和上述的<code>Promise.resolve()</code>类似，它也是<code>new Promise（）</code>的快捷方式。</p>
<pre><code>Promise.reject(new Error('error'));

/*******等同于*******/
new Promise(function (resolve, reject) {
    reject(new Error('error'));
});
</code></pre>

<p>这段代码会让这个Promise对象立即进入<code>rejected</code>状态，并将错误对象传递给<code>then</code>指定的<code>onRejected</code>回调函数。</p>
<h2>4.Promise常见问题</h2>
<h4>创建promise的流程：</h4>
<ul>
<li>使用<code>new Promise(fn)</code>或者它的快捷方式<code>Promise.resolve()</code>、<code>Promise.reject()</code>,返回一个promise对象 </li>
<li>
<p>在<code>fn</code>中指定异步的处理</p>
<p>处理结果正常，调用resolve</p>
<p>处理结果错误，调用reject</p>
</li>
</ul>
<h4>reject和catch的区别</h4>
<ul>
<li>
<p>promise.then(onFulfilled,onRejected) </p>
<pre><code>在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。
</code></pre>

</li>
<li>
<p>promise.then(onFulfilled).catch(onRejected)</p>
<pre><code>.then中产生的异常能在.catch中捕获
</code></pre>

</li>
</ul>
<h4>实例</h4>
<p>如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误</p>
<pre><code>function taskA() {
    console.log(x);
    console.log(&quot;Task A&quot;);
}
function taskB() {
    console.log(&quot;Task B&quot;);
}
function onRejected(error) {
    console.log(&quot;Catch Error: A or B&quot;, error);
}
function finalTask() {
    console.log(&quot;Final Task&quot;);
}
var promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask);

-------output-------
Catch Error: A or B,ReferenceError: x is not defined
Final Task
</code></pre>

<p>A抛错时，会按照 taskA → onRejected → finalTask这个流程来处理。A抛错后，若没有对它进行处理，如例3.7，状态就会维持rejected，taskB不会执行，直到catch了错误。</p>
<pre><code>function taskA() {
    console.log(x);
    console.log(&quot;Task A&quot;);
}
function taskB() {
    console.log(&quot;Task B&quot;);
}
function onRejectedA(error) {
    console.log(&quot;Catch Error: A&quot;, error);
}
function onRejectedB(error) {
    console.log(&quot;Catch Error: B&quot;, error);
}
function finalTask() {
    console.log(&quot;Final Task&quot;);
}
var promise = Promise.resolve();
promise
    .then(taskA)
    .catch(onRejectedA)
    .then(taskB)
    .catch(onRejectedB)
    .then(finalTask);

-------output-------
Catch Error: A ReferenceError: x is not defined
Task B
Final Task
</code></pre>

<p>在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。</p>
<pre><code>//方法1：对同一个promise对象同时调用 then 方法
var p1 = new Promise(function (resolve) {
    resolve(100);
});
p1.then(function (value) {
    return value * 2;
});
p1.then(function (value) {
    return value * 2;
});
p1.then(function (value) {
    console.log(&quot;finally: &quot; + value);
});
-------output-------
finally: 100

//方法2：对 then 进行 promise chain 方式进行调用
var p2 = new Promise(function (resolve) {
    resolve(100);
});
p2.then(function (value) {
    return value * 2;
}).then(function (value) {
    return value * 2;
}).then(function (value) {
    console.log(&quot;finally: &quot; + value);
});
-------output-------
finally: 400
</code></pre>

<p>第一种方法中，then的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。</p>
<pre><code>function task1(data) {
    var promise = Promise.resolve(data);
    promise.then(function(value) {
        //do something
        return value + 1;
    });
    return promise;
}
task1(10).then(function(value) {
   console.log(value);          //想要得到11，实际输出10
});
-------output-------
10

/* 正确的写法 */

function task2(data) {
    var promise = Promise.resolve(data);
    return promise.then(function(value) {
        //do something
        return value + 1;
    });
    return promise;
}
task2(10).then(function(value) {
   console.log(value);
});
-------output-------
11
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
